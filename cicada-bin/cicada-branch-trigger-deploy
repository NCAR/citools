#!/bin/sh
PROG=cicada-branch-trigger-deploy
DESC="Trigger a deployment in CircleCI"
USAGE="${PROG}"

HELP_DESC="
This script logs a deployment authorization and triggers the deployment
of an image for another project. It is meant to be run in a CircleCI job
that is triggered when an image metadata file is uploaded to a branch in
the \"CICADA\" github repo.
"
SCRIPTDIR=`cd \`dirname $0\`; pwd`
SCRIPTPARENT=`dirname ${SCRIPTDIR}`

. ${SCRIPTPARENT}/citools-basics.rc || exit 1

PATH="${SCRIPTPARENT}:${SCRIPTDIR}:$PATH" export PATH

case ${CIRCLE_BRANCH} in
    '')
      echo "${PROG}: Not running from a CircleCI job" >&2
      exit 1 ;;
    master)
      echo "${PROG}: Nothing to be done on master branch" >&2
      exit 0 ;;
esac

TARGET_REPO=`expr "${CIRCLE_BRANCH}" : '\(.*\)-[^-][^-]*$'`
if [ ":${TARGET_REPO}" = ":" ] ; then
    echo "${PROG}: Unsupported branch name" >&2
    exit 1
fi
TARGET_ENV=`expr "${CIRCLE_BRANCH}" : '.*-\([^-][^-]*\)$'` ;;

# Load CICADA configuration for project
DEFAULT_CONFIG=`git show master:DEFAULTS.rc`
PROJECT_CONFIG=`git show master:${TARGET_REPO}.rc`
eval "${DEFAULT_CONFIG}"
eval "${PROJECT_CONFIG}"

set : `cicada-branch-get-last-commit`
shift
IMAGE_META_FILE="$1"
shift
COMMITINFO="$*"
if [ ":${IMAGE_META_FILE}" = ":" ] ; then
    exit 1
fi
# The following command should set REPO_OWNER, REPO_NAME, VERSION
. ${IMAGE_META_FILE}

if [ "${REPO_NAME}" != "${TARGET_REPO}" ] ; then
    if [ "${REPO_NAME}" != "${REPO_NAME}_${TARGET_REPO}" ] ; then
        echo "${PROG}: Image repo name does not match branch name" >&2
        exit 1
    fi
fi

VERS_NUM=`parse-semver -n ${VERSION}`
VERS_META=`parse-semver -m ${VERSION}`
if [ "${TARGET_ENV}" = "${PRODUCTION_ENVIRONMENT}" ] ; then
    TARGET_TAG="${VERS_NUM}${VERS_META}"
else
    TARGET_TAG="${VERS_NUM}-${TARGET_ENV}${VERS_META}"
fi
RELEASE_NAME="${VERS_NUM}${VERS_META}"
REPO="${REPO_OWNER}/${REPO_NAME}"
export REPO RELEASE_NAME TARGET_TAG

for var in IMAGE_META_FILE COMMITINFO REPO RELEASE_NAME TARGET_TAG ; do
    eval val=\"\$${var}\"
    vecho "${var}=${val}"
done

install-jq $SCRIPTDIR || exit 1

RELEASE_OBJ=`github-get-release-by-name --repo=${REPO} ${RELEASE_NAME}`
if [ ":${RELEASE_OBJ}" = ":" ] ; then
    echo "${PROG}: No release object for ${REPO}:${RELEASE_NAME}" >&2
    exit 1
fi
RELEASE_TAG=`echo "${RELEASE_OBJ}" | jq -r .tag_name`
vecho RELEASE_TAG="${RELEASE_TAG}"

#
# If release's tag matches the image's tag, use the CircleCI API to
# trigger a rebuild. Otherwise, update the release tag with the
# image's tag, which should trigger a CircleCI build
#
if [ ":${RELEASE_TAG}" = ":${TARGET_TAG}" ] ; then
    vecho "Current release tag matches target"
    vecho "Triggering build via CircleCI API call"
    TRIGGER_BUILD_PATH="/project/github/${REPO}/build"
    echo "{\"tag\":\"${TARGET_TAG}\"}" |
        circle-post "${TRIGGER_BUILD_PATH}" >/dev/null || exit 1
else
    vecho "Current release tag does not matches target"
    vecho "Triggering build by updating release tag"
    RELEASE_ID=`echo "${RELEASE_OBJ}" | jq -r .id`
    old_data=`echo "${RELEASE_OBJ}" |
       jq '{tag_name,target_commitish,name,body,draft,prerelease}'`

    new_data=`echo "$old_data" |
      sed -e 's/"tag_name": ".*",/"tag_name": "'${TARGET_TAG}'",/'`
    cat "${new_data}" |
        github-patch "/repos/${REPO}/releases/${RELEASE_ID}" >/dev/null ||
          exit 1
fi

exit 0
