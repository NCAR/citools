#!/bin/sh
PROG="circle-workspace-init"
DESC="Initialize the workspace for a CircleCI workflow"
USAGE1="${PROG} [--root=<workspace_root>] [--bin=<workspace_bin>] \
                          [--state=<workspace_state>] --initrc=<init_rc>"

HELP_DESC="
This script initializes the \"workspace\" at the start of a CircleCI
workflow.

A CircleCI configuration should define a workspace root directory and create
two directories under it: one for dynamically-installed software and one
for workflow state. It should then install the \"citools\" scripts into
the workspace and invoke this script:

  mkdir -p \${WORKSPACE}/bin \${WORKSPACE}/state
  git clone --depth 1 git@github.com:NCAR/citools.git \${WORKSPACE}/bin
  \${WORKSPACE}/bin/circle-workspace-init \\
      --root=${WORKSPACE} --bin=bin --state=state \\
      --init-rc=${WORKSPACE}/state/init.rc

Following these commands, the configuration should run a
\"persist_to_workspace\" job step with the root set to the \$WORKSPACE
directory and paths \"bin\" and \"state\":

  - persist_to_workspace:
      root: workspace
      paths:
        - bin
        - state

In subsequent jobs that attach the workspace, \"run\" job steps in the
workflow should begin with the following command:

  . \${WORKSPACE}/state/init.rc

The \"\${WORKSPACE}/state/init.rc\" file is written by $PROG.
It contains environment variable definitions useful to subsequent
jobsteps. The name of the file is stored in its own environment variable,
INIT_RC; the definition of INIT_RC is actually included in init.rc.
See circle-env for more information on the environment variables
defined.

In addition to writing the \"init.rc\" file, $PROG
installs the \"jq\" utility (and possibly other software) in
\${WORKSPACE}/bin, and caches \"docker login\" commands.
"
HELP_OPTS="
--root=<workspace_root>
    The root directory of the workspace. The path can be absolute or
    relative to \$CIRCLE_WORKING_DIRECTORY. The path will be stored in the
    WORKSPACE environment variable in the <init_rc> file. If not given,
    the WORKSPACE environment variable must be set.

--bin=<workspace_bin>
    A directory in which dynamically-installed software should be
    installed. If given, the path must be absolute or relative to
    \$WORKSPACE. If absolute, it must be under \$WORKSPACE. If not given,
    the LOCAL_BIN environment variable will be used if set, otherwise the
    script's own directory is used. The path will be stored in the
    LOCAL_BIN environment variable in the <init_rc> file.

--state=<workspace_state>
    A directory in which workflow state will be stored. If given, the
    path must be absolute or relative to \$WORKSPACE. If absolute, it
    must be under \$WORKSPACE. If not given, the STATEDIR environment
    variable will be used if set, otherwise \$WORKSPACE/state is
    used. The path will be stored in the STATEDIR environment variable
    in the <init_rc> file.

--initrc=<init_rc>
    A path of a file into which environment variable definitions will be
    written. If given, the path must be absolute or relative to
    \$WORKSPACE. If absolute, it must be under \$WORKSPACE. If not given,
    the INIT_RC environment variable will be used if set; otherwise
    \$WORKSPACE/state/init.rc is used.  The path will be stored in the
    INIT_RC environment variable in the <init_rc> file.
"
SCRIPTDIR=`cd \`dirname $0\`; pwd`
. ${SCRIPTDIR}/citools-basics.rc || exit 1

#
# Collect and validate command-line arguments and defaults
#
root="${WORKSPACE}"
initrc="${INIT_RC}"
bin="${LOCAL_BIN}"
state="${STATEDIR}"
while [ $# != 0 ] ; do
    case $1 in
        --root=/*)
            root=`expr "$1" : '--root=\(.*\)$'` ;;
        --root=*)
            root=${CIRCLE_WORKING_DIRECTORY}/`expr "$1" : '--root=\(.*\)$'` ;;
        --bin=*)
            bin=`expr "$1" : '--bin=\(.*\)$'` ;;
        --state=*)
            state=`expr "$1" : '--state=\(.*\)$'` ;;
        --initrc=*)
            initrc=`expr "$1" : '--initrc=\(.*\)$'` ;;
    esac
    shift
done

# Normalize root dir
if [ ":${root}" = ":" ] ; then
    echo "${PROG}: --root is required" >&2
    exit 1
else
    root=`cd ${root}; pwd`
fi
mkdir -p "${root}" || exit 1

# Make sure all other paths are set and absolute
if [ ":${bin}" = ":" ] ; then
    bin="${root}/bin"
fi
if [ ":${state}" = ":" ] ; then
    state="${root}/state"
fi
if [ ":${initrc}" = ":" ] ; then
    initrc="${state}/init.rc"
fi
for var in bin state initrc ; do
    eval val=\"\$${var}\"
    case $val in
        /*) : ;;
        *)  val="${root}/${val}"
            eval ${var}=\""${val}"\" ;;
    esac
done
mkdir -p "${bin}" "${state}" || exit 1

# normalize all other paths
bin=`cd ${bin}; pwd`
state=`cd ${state}; pwd`
initrc_parent=`dirname "${initrc}"`
mkdir -p ${initrc_parent} || exit 1
initrc_parent=`cd ${initrc_parent}; pwd` 
initrc="${initrc_parent}/`basename ${initrc}`"

# Make sure all paths are under root
finally=:
for var in bin state initrc ; do
    eval val=\"\$${var}\"

    case ${val} in
        ${root}/*)
            : ;;
        *)
            echo "${PROG}: --${var} path  must be under ${root}" >&2
            finally="exit 1" ;;
    esac
done
eval $finally

WORKSPACE="${root}" export WORKSPACE
LOCAL_BIN="${bin}"  export LOCAL_BIN
STATEDIR="${state}" export STATEDIR
INIT_RC="${initrc}" export INIT_RC
for var in WORKSPACE LOCAL_BIN STATEDIR INIT_RC ; do
    eval val=\"\$${var}\"
    vecho "${var}=${val}"
    export ${var}
done

${SCRIPTDIR}/circle-env "${INIT_RC}"
. ${INIT_RC}

if [ ! -x "${CDIMPL}" ] ; then
    echo "${PROG}: no script found for CDIMPL=${CDIMPL}" >&2
    exit 1
fi

set -e
circle-install-tools ${LOCAL_BIN}
if [ ":${IMAGE_NAME}" != ":" ] ; then
    circle-docker-login-init ${IMAGE_NAME}
fi

${CDIMPL} init

if truthy ${CITOOLS_VERBOSE} ; then
    circle-debug-dump
fi

exit 0