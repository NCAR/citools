#!/bin/sh
PROG=docker-cibuild
DESC="Run \"docker build\" with added labels, produce metadata"
USAGE1="${PROG} [--metadata=<metadata_file>] [--image-name=<image_name>]
                    [--source-version=<src_vers>]
                    [--image-qualifier=<img_qual>] <BUILD_OPTS>"
METADATA_VERSION=1.0.0

RELEASE_TAG="${RELEASE_TAG:-${CIRCLE_TAG}}"
SOURCE_VERSION_DEFAULT=`parse-semver -n "${RELEASE_TAG}" 2>/dev/null`

HELP_DESC="
This script runs \"docker build\", adds some useful labels, and applies a
unique tag to the resulting image. It also captures the build output,
extracts data from it, supplements it with information from \"docker
inspect\" and various git commands, and writes this metadata to a file.

Note that this will not work if the -q|--quiet option to \"docker
build\" is given.

The following arguments are automatically passed to \"docker build\" in
addition to any provided arguments:
    --label git.remote.origin=<github_repo_url>
    --label git.revision.sha1=<git_commit_hash>
    --label image.registry=<image_registry>
    --label image.repo=<image_repo>
    --label image.name=<tagless_name>    # see --image-name
    --label image.qualifier=<img_qual>   # see --image-qualifier
    --label source.version=<src_vers>    # see --source-version

Metadata is in JSON format as <parameter>:<value> entries, in the
given order:

  Parameter          Value
  ---------          -----
  metadata_version   The version of the metadata format; current value is
                     \"${METADATA_VERSION}\".
  remote_origin      The github repo URL
  git_repo           The username and repo name of the github repo, with
                      a separating \"/\".
  revision_sha1      The full sha1 hash of the current git revision
  source_version     The source version (see --source-version=<src_vers>)
  image_created      The ISO8601 UTC creation time of the image
                     (nanosecond resolution)
  image_digest       The digest of the image (with leading \"sha256:\")
  image_id           The first 12 characters of the image digest
  image_registry     The name of the target docker registry.
  image_repo         The name of the target docker repository.
  image_name         The name of the image.
  image_qualifier    The image qualifier (see --image-qualifier=<img_qual>)
  image_tag          The unique tag assigned to the image by this script;
                     it has the form
                         <source_version>-<ctime>[-<image_qualifier>]    
                     where <ctime> is a compact form of the image creation
                     time.
  base_tag           The full (pullable) \"tag name\" of the base image
  base_digest        The full (pullable) \"digest name\" of the base image
  base_remote_origin The github repo url for the base image, if the base
                     image was built by this script.
  base_git_repo      The username and repo name of the github repo for the
                     base image, with a separating \"/\"; only available
                     if the base image was built by this script.

The \"image_registry\", \"image_repo\", and \"image_name\" are assigned
defaults using the docker-image-name script.

The basename of the metadata file is the image name.

The image is tagged as <image_name>:<image_tag>.
"
HELP_OPTS="
--metadata=<metadata_file>
    If given, the name of a local file into which the image metadata
    should be written. If not given, \"./<image_name>:<image_tag>\" is used.

--image-name=<image_name>
    The name of the docker image (without registry or repository components).
    This is required if the IMAGE_NAME environment variable is not set.

--source-version=<src_vers>
    The version number of the source revision. By convention, this is a
    normal semantic version string, without a prerelease or metadata parts.
    It will form part of the unique docker tag for the image, so it must
    consist of legal tag characters. This is required if the SOURCE_VERSION
    environment variable is not set.

--image-qualifier=<img_qual>
    If given, a string that distinguishes the image from other images, or
    provides build metadata. It will form part of the unique docker tag for
    the image, so it must consist of legal tag characters. If not given,
    the IMAGE_QUALIFIER environment variable is used.

<BUILD_OPTS>
    \"docker build\" options, which are passed through. Including
    -q|--quiet will cause an error.
"
HELP_ENV="
IMAGE_QUALIFIER
    The default for the --image-qualifier argument.

SOURCE_VERSION
    The default for the --source-version argument. If not set, the script
    attempts to extract a version string from the RELEASE_TAG and
    CIRCLE_TAG environment variables.
"

SCRIPTDIR=`cd \`dirname $0\`; pwd`
. ${SCRIPTDIR}/citools-basics.rc || exit 1

set : "$@" ====
shift
abort_on_error=:
eval `docker-image-name --export`
SOURCE_VERSION="${SOURCE_VERSION:-${SOURCE_VERSION_DEFAULT}}"
while [ ":$1" != ":====" ] ; do
    arg="$1"
    shift
    case ${arg} in
        --metadata=*)
            IMAGE_METADATA=`expr "${arg}" : '--metadata=\(.*\)$'` ;;
        --image-name=*)
            IMAGE_NAME=`expr "${arg}" : '--image-name=\(.*\)$'` ;;
        --source-version=*)
            SOURCE_VERSION=`expr "${arg}" : '--source-version=\(.*\)$'` ;;
        --image-qualifier=*)
            IMAGE_QUALIFIER=`expr "${arg}" : '--image-qualifier=\(.*\)$'` ;;
        *)
            set : "$@" "${arg}"
            shift ;;
    esac
done 
shift
if [ ":${IMAGE_NAME}" == ":" ] ; then
    echo "${PROG}: --image-name argument is required" >&2
    abort_on_error='exit 1'
fi
if [ ":${SOURCE_VERSION}" == ":" ] ; then
    echo "${PROG}: --source-version argument is required" >&2
    abort_on_error='exit 1'
elif expr "${SOURCE_VERSION}" : '.*[^-._0-9a-zA-Z].*' >/dev/null ; then
    echo "${PROG}: Invalid source version string: ${SOURCE_VERSION}" >&2
    abort_on_error='exit 1'
fi
if expr "${IMAGE_QUALIFIER}" : '.*[^-._0-9a-zA-Z].*' >/dev/null ; then
    echo "${PROG}: Invalid image qualifier string: ${IMAGE_QUALIFIER}" >&2
    abort_on_error='exit 1'
elif expr "${IMAGE_QUALIFIER}" : '[^-].*' >/dev/null ; then
    IMAGE_QUALIFIER="-${IMAGE_QUALIFIER}"
fi
eval $abort_on_error

toplevel=`git rev-parse --show-toplevel 2>/dev/null`

if [ ":$toplevel" != ":" ] ; then
    gitRemoteOrigin=`git config --get remote.origin.url`
    gitRevisionSha1=`git rev-list HEAD | head -1`
    set : --label "git.remote.origin=${gitRemoteOrigin}" \
          --label "git.revision.sha1=${gitRevisionSha1}" \
          --label "image.registry=${IMAGE_REGISTRY}" \
          --label "image.repo=${IMAGE_REPO}" \
          --label "image.name=${IMAGE_NAME}" \
          --label "image.qualifier=${IMAGE_QUALIFIER}" \
          --label "source.version=${SOURCE_VERSION}" \
"$@"
    shift
fi

SCRATCHDIR="/tmp/citools$$.d"
mkdir -p "${SCRATCHDIR}" || exit 1
trap "rm -rf ${SCRATCHDIR} ; exit 1" 0 1 2 13 15

docker build "$@" | tee ${SCRATCHDIR}/docker-build.out

# Retrieve baseId and imageId from docker build output
eval `awk '
BEGIN { state = "looking" }
/^Step [0-9]+\/[0-9]+ : [fF][rR][oO][mM]/ {
    state = "sawfrom"
    next
}
/^ ---> [0-9a-f]*$/ {
    if (state == "sawfrom") {
        baseId = $2
    }
    state = "looking"
}
/^Successfully built / {
    id = $3
}
{
    next
}
END {
    if ((baseId != "") && (id != "")) {
        printf("baseId=%s imageId=%s\n",baseId,id);
    }
}' ${SCRATCHDIR}/docker-build.out`

rm -rf "${SCRATCHDIR}"
trap "" 0

imageInfo=`docker inspect --format='{{.Id}} {{.Created}}' ${imageId}`
if [ ":${imageInfo}" = ":" ] ; then
    echo "${PROG}: unable to retrieve image data for $imageId" >&2
    exit 1
fi
set : ${imageInfo}
imageDigest="$2"
imageCreated="$3"
imageCtime=`echo ${imageCreated} | sed -e 's/[-:]//g' -e 's/\.[0-9]*Z$/Z/'`

baseTag= baseDigest= baseRemoteOrigin=
if [ ":${baseId}" != ":" ] ; then
    baseInfo=`docker inspect --format='{{index .RepoTags 0}} {{index .RepoDigests 0}} {{index .Config.Labels "git.remote.origin"}}' ${baseId}`
    if [ ":${baseInfo}" != ":" ] ; then
        set : ${baseInfo}
        baseTag="$2"
        baseDigest="$3"
        baseRemoteOrigin="$4"
    fi
fi
gitRepo=`expr "${gitRemoteOrigin}" : '.*[:/]\([^:/][^:/]*/[^:/][^:/]*\)\.git$'`
baseGitRepo=`expr "${baseRemoteOrigin}" : '.*[:/]\([^:/][^:/]*/[^:/][^:/]*\)\.git$'`

imageTag="${SOURCE_VERSION}-${imageCtime}${IMAGE_QUALIFIER}"
imageTaggedName="${IMAGE_NAME}:${imageTag}"
docker tag "${imageId}" "${imageTaggedName}" || exit 1

if [ ":${IMAGE_METADATA}" = ":" ] ; then
    IMAGE_METADATA="./${imageTaggedName}"
else
    mkdir -p `dirname ${IMAGE_METADATA}` || exit 1
fi

cat <<EOF >"${IMAGE_METADATA}"
{
  "metadata_version": "${METADATA_VERSION}",
  "remote_origin": "${gitRemoteOrigin}",
  "git_repo": "${gitRepo}",
  "revision_sha1": "${gitRevisionSha1}",
  "source_version": "${SOURCE_VERSION}",
  "image_created": "${imageCreated}",
  "image_digest": "${imageDigest}",
  "image_id": "${imageId}",
  "image_registry": "${IMAGE_REGISTRY}",
  "image_repo": "${IMAGE_REPO}",
  "image_name": "${IMAGE_NAME}",
  "image_qualifier": "${IMAGE_QUALIFIER}",
  "image_tag": "${imageTag}",
  "base_tag": "${baseTag}",
  "base_digest": "${baseDigest}",
  "base_remote_origin": "${baseRemoteOrigin}",
  "base_git_repo": "${baseGitRepo}"
}
EOF

exit 0

