#!/bin/sh
PROG=trigger-deployment
DESC="Trigger a deployment in CircleCI from a \"cicada\" CircleCI job"
USAGE="${PROG} [-h|--help]"
SCRIPT_VERSION=0.0.2

case $1 in
  -h|--help)
    cat <<EOF
NAME
    $PROG - $DESC

SYNOPSIS
    $USAGE

DESCRIPTION
    This script logs a deployment authorization and triggers the deployment
    of an image for another project. It is meant to be run in a CircleCI job
    that is triggered when an image metadata file is uploaded to a branch in
    the "CICADA" github repo.
EOF
    exit 0 ;;
esac
a="/$0"; a=${a%/*}; a=${a#/}; a=${a:-.}; SCRIPTDIR=$(cd "$a"; pwd)

cd `git rev-parse --show-toplevel` || exit 1

case ${CIRCLE_BRANCH} in
    '')
      echo "${PROG}: Not running from a CircleCI job" >&2
      exit 1 ;;
    master)
      echo "${PROG}: Nothing to be done on master branch" >&2
      exit 0 ;;
    *-test)
      TARGET_ENV=test
      SEMVER_SUFFIX=-test
      TARGET_REPO=`expr "${CIRCLE_BRANCH}" : '\(.*\)-test$'` ;;
    *-staging)
      TARGET_ENV=staging
      SEMVER_SUFFIX=-staging
      TARGET_REPO=`expr "${CIRCLE_BRANCH}" : '\(.*\)-staging$'` ;;
    *-production)
      TARGET_ENV=production
      SEMVER_SUFFIX=
      TARGET_REPO=`expr "${CIRCLE_BRANCH}" : '\(.*\)-production$'` ;;
    *)
      echo "${PROG}: Unsupported branch name: ${CIRCLE_BRANCH}" >&2
      exit 0 ;;
esac

#
# Write intermediate files. This is primitive, but it helps when debugging;
# when debugging, set TMPDIR to '.' and comment out the trap (which cleans
# up the temp directory).
#
TMPDIR=/tmp/$$.d
trap "rm -rf ${TMPDIR} ; exit 1" 0 1 2 13 15
mkdir -p "${TMPDIR}" || exit 1

git rev-list HEAD >${TMPDIR}/revlist

# Find the most recent updated file that looks like an image metadata file
while read release ; do
    filename=`git diff-tree --no-commit-id --name-only -r "${release}"`
    imagename=`expr "${filename}" : '\([0-9][0-9]*.[0-9][0-9]*.[0-9][0-9]*-[0-9.]*Z\).*'`
    if [ ":${imagename}" != ":" ] ; then
        echo "${imagename}" >${TMPDIR}/imagename
        git log -1 --pretty=format:"by %ce at %cd" >${TMPDIR}/commitinfo
        break
    fi
done <${TMPDIR}/revlist
read IMAGENAME <${TMPDIR}/imagename
RELEASE_TAG=`expr "${IMAGENAME}" : '\([0-9.]*\)-.*'`

finally=:
for var in CIRCLE_BRANCH TARGET_ENV TARGET_REPO IMAGENAME RELEASE_TAG ; do
    eval "val=\$${var}"
    if [ ":${val}" = ":" ] ; then
        echo "${PROG}: variable ${var} not set" >&2
        finally="exit 1"
    fi
done
eval ${finally}

. ${IMAGENAME} || exit 1

SEMVER_TAG="${RELEASE_TAG}${SEMVER_SUFFIX}"
export REPO_OWNER REPO_NAME RELEASE_TAG

finally=:
for var in REPO_OWNER REPO_NAME SEMVER_TAG; do
    eval "val=\$${var}"
    if [ ":${val}" = ":" ] ; then
        echo "${PROG}: variable ${var} not set" >&2
        finally="exit 1"
    fi
done
eval ${finally}

if [ "${REPO_NAME}" != "${TARGET_REPO}" ] ; then
    if [ "${REPO_NAME}" != "${REPO_NAME}_${TARGET_REPO}" ] ; then
        echo "${PROG}: Image repo name does not match branch name" >&2
        exit 1
    fi
fi

# Check if desired semantic version tag exists. If it does not exist, create
# it to trigger a CircleCI job via webhook. If it does exist, use the CircleCI
# API to trigger a job
echo 'create_tag' >${TMDIR}/action
git ls-remote --tags "git@github.com:${REPO_OWNER}/${REPO_NAME}.git" |
    while read release fulltag ; do
        tag=`expr "${fulltag}" : '.*/\([^/]*$'`
        if [ ":$tag" = "${SEMVER_TAG}" ] ; then
            echo 'trigger_job' >${TMDIR}/action
            break
        fi
    done
read ACTION <${TMPDIR}/action
echo ACTION=$ACTION

# Make an entry in the log
read COMMIT_INFO <${TMPDIR}/commitinfo
LOGENTRY="${IMAGENAME} ${CIRCLE_BRANCH} authorized $COMMIT_INFO"
echo LOGENTRY=${LOGENTRY}

${SCRIPTDIR}/cicada-writelog "${LOGENTRY}" || exit 1

#
# Add log entry for deployment authorization
# If release tag does not exist
#  create it - this will trigger build
# else
#  trigger job
# 

rm -rf ${TMPDIR}
trap "" 0

exit 0


